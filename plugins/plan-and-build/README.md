# Plan & Build

구조화된 개발 워크플로우 플러그인.

AI에게 바로 코딩을 시키지 않고, **Research → Plan → Annotation Cycle → Todo → Implementation** 단계를 분리하여 의사결정은 사람이, 실행은 AI가 하는 워크플로우를 제공합니다.

> Boris Tane의 "How I Use Claude Code" 블로그 글에서 영감을 받았습니다.

## 왜 이 워크플로우인가?

AI에게 "인증 시스템 만들어줘"라고 바로 시키면 일어나는 일:

- AI가 자기 판단으로 아키텍처를 결정함
- 원치 않는 방향으로 수백 줄이 생성됨
- 되돌리기 어려움, 맥락 손실

Plan & Build는 이 문제를 해결합니다:

1. **AI가 먼저 조사**하고 → 사람이 검토
2. **AI가 계획을 세우**고 → 사람이 수정/승인
3. **승인된 계획만 실행** → 예측 가능한 결과

## 설치

```
/plugin install plan-and-build@waymakerlabs-claude-plugins
```

## 기본 사용법

```
/plan-and-build 사용자 인증 시스템 추가
```

인자 없이 실행하면 어떤 작업인지 물어봅니다:

```
/plan-and-build
```

## 워크플로우 단계

```
/plan-and-build {작업}
        │
        ▼
  ┌─────────────┐
  │  1. Research │  AI가 코드베이스를 깊이 분석
  │              │  → docs/plan-and-build/research.md 생성
  └──────┬──────┘
         │  "계획 시작" ← 사용자 승인
         ▼
  ┌─────────────┐
  │  2. Plan    │  AI가 구현 계획 수립
  │              │  → docs/plan-and-build/plan.md 생성
  └──────┬──────┘
         │
         ▼
  ┌─────────────────────┐
  │  3. Annotation Cycle │ ◄─── 반복 가능
  │                      │
  │  사용자: plan.md에    │  "주석 반영해줘" → AI가 반영
  │  인라인 주석 추가     │  "주석 반영해줘" → AI가 반영
  │                      │  ...만족할 때까지
  └──────┬──────────────┘
         │  "구현 시작" ← 사용자 승인
         ▼
  ┌─────────────┐
  │  4. Todo    │  plan.md에 체크리스트 추가
  └──────┬──────┘
         │
         ▼
  ┌──────────────────┐
  │  5. Implementation│  계획대로 기계적 실행
  │                   │  완료마다 체크박스 ✅ 업데이트
  └──────┬───────────┘
         │
         ▼
  ┌─────────────┐
  │  6. 완료 보고 │
  └─────────────┘
```

| 단계 | 주체 | 산출물 |
|------|------|--------|
| Research | AI | `research.md` |
| Plan | AI | `plan.md` |
| Annotation Cycle | 사람 + AI | `plan.md` 업데이트 |
| Todo | AI | `plan.md`에 체크리스트 추가 |
| Implementation | AI | 실제 코드 변경 |

## 실전 활용 예시

### 예시 1: 새 기능 추가

```
/plan-and-build API에 rate limiting 미들웨어 추가
```

1. AI가 기존 미들웨어 구조, 라우터 패턴, 의존성을 조사
2. `research.md`에 기존 Express 미들웨어 체인, Redis 사용 여부 등 정리
3. 사용자가 리서치 확인 후 → `계획 시작`
4. `plan.md`에 구현 전략 작성 (예: sliding window vs token bucket)
5. 사용자가 plan.md를 열어 주석 추가:
   - `<!-- token bucket 대신 sliding window로 해주세요 -->`
   - `<!-- Redis 말고 in-memory로 충분합니다 -->`
6. `주석 반영해줘` → AI가 계획 수정
7. `구현 시작` → 승인된 계획대로 구현

### 예시 2: 리팩토링

```
/plan-and-build 모놀리식 UserService를 도메인별로 분리
```

1. AI가 UserService의 모든 메서드, 호출처, 의존성을 분석
2. `research.md`에 영향 범위와 의존 그래프 정리
3. `plan.md`에 분리 전략 작성 (AuthService, ProfileService, ...)
4. 사용자가 파일별 변경 계획을 검토하며 주석:
   - `<!-- NotificationService도 분리해주세요 -->`
   - `<!-- Phase 2는 나중에 하고, Phase 1만 먼저 -->`
5. 여러 차례 주석 사이클 후 최종 승인 → 구현

### 예시 3: 버그 수정 (복잡한 경우)

```
/plan-and-build 결제 처리 시 동시성 이슈로 중복 결제 발생하는 버그 수정
```

1. AI가 결제 플로우 전체를 추적, 트랜잭션 처리 방식, 락 메커니즘 조사
2. `research.md`에 현재 동시성 처리 방식과 문제점 분석
3. `plan.md`에 수정 전략 작성 (optimistic locking, idempotency key 등)
4. 사용자가 plan.md 리뷰 — 금융 관련이라 꼼꼼하게
5. 승인 후 → 구현

## 주석 사이클 활용법

주석 사이클은 이 워크플로우의 핵심입니다. plan.md를 에디터에서 열고 인라인 주석을 추가하세요.

### 주석 작성 방법

HTML 주석이나 일반 텍스트 모두 가능합니다:

```markdown
## 구현 전략 개요

JWT 기반 인증을 구현합니다.
<!-- 세션 기반으로 변경해주세요. JWT는 토큰 무효화가 어렵습니다. -->

### Phase 1: 데이터베이스 스키마

users 테이블에 password_hash 컬럼을 추가합니다.
<!-- argon2 대신 bcrypt 사용. 이미 bcrypt 의존성이 있습니다. -->
```

### 주석 유형 예시

**방향 수정:**
```markdown
<!-- 이 부분은 다른 접근이 필요합니다. Redis 대신 PostgreSQL advisory lock을 사용해주세요. -->
```

**항목 추가:**
```markdown
<!-- 여기에 에러 로깅도 추가해주세요. Sentry 연동 필요. -->
```

**항목 거부:**
```markdown
<!-- 이 Phase는 빼주세요. 지금은 범위에 포함시키지 않겠습니다. -->
```

**질문/의견:**
```markdown
<!-- 이 방식이면 기존 API 호환성이 깨지지 않나요? breaking change 없이 가능한 방법으로 수정해주세요. -->
```

### 주석 사이클 진행

```
사용자: (plan.md에 주석 추가)
사용자: "주석 반영해줘"
  AI: ✏️ 주석 반영 완료! 변경사항: ...

사용자: (다시 확인, 추가 주석)
사용자: "주석 반영해줘"
  AI: ✏️ 주석 반영 완료! 변경사항: ...

사용자: "구현 시작"
  AI: (체크리스트 생성 → 구현 시작)
```

보통 1~3회면 충분하지만 필요하면 더 반복할 수 있습니다.

## 세션 이어하기

이전 세션에서 중단된 작업을 이어갈 수 있습니다.

```
/plan-and-build 사용자 인증 시스템 추가
```

기존 `docs/plan-and-build/research.md` 또는 `plan.md`가 있으면:

```
이전 작업 문서가 있습니다. 새로 시작할까요, 이어서 할까요?
  - "새로 시작" → 기존 문서 삭제, 처음부터
  - "이어서 하기" → 기존 문서 유지, 중단된 단계부터 재개
```

활용 시나리오:
- 어제 리서치까지 했는데, 오늘 계획부터 이어서 하고 싶을 때
- 계획은 세웠는데 구현 중 세션이 끊겼을 때

## 생성되는 문서

프로젝트 루트의 `docs/plan-and-build/` 폴더에 생성됩니다:

```
your-project/
├── docs/
│   └── plan-and-build/
│       ├── research.md   ← 코드베이스 분석 결과
│       └── plan.md       ← 구현 계획 + 체크리스트
├── src/
└── ...
```

### research.md

| 섹션 | 내용 |
|------|------|
| 관련 코드 구조 및 아키텍처 | 프로젝트 구조, 모듈, 데이터 흐름 |
| 기존 패턴 및 컨벤션 | 코딩 스타일, 네이밍, 디자인 패턴 |
| 의존성 및 영향 범위 | 변경 시 영향받는 파일/모듈 |
| 주의사항 및 잠재적 충돌 | 엣지 케이스, 기술적 제약 |
| 참고 파일 | 관련 파일 목록과 역할 |

### plan.md

| 섹션 | 내용 |
|------|------|
| 구현 전략 개요 | 전체 접근 방식과 이유 |
| 수정할 파일 목록 | 경로, 변경 유형, 설명 |
| 상세 변경 계획 | Phase별, 파일별 코드 스니펫 포함 |
| 트레이드오프 고려사항 | 대안 비교와 선택 이유 |
| 구현 순서 | Phase 순서와 이유 |
| 구현 체크리스트 | 진행상황 추적용 (구현 시작 시 추가) |

문서는 구현 후에도 삭제되지 않습니다. 나중에 "왜 이렇게 구현했는지" 참고할 수 있습니다.

## 언제 쓰면 좋은가?

| 상황 | Plan & Build | 바로 코딩 |
|------|:---:|:---:|
| 새 기능 (여러 파일 변경) | O | |
| 아키텍처 변경/리팩토링 | O | |
| 복잡한 버그 수정 | O | |
| 기술적 의사결정이 필요한 작업 | O | |
| 한 줄 버그 수정 | | O |
| 간단한 UI 수정 | | O |
| 타입 에러 수정 | | O |

**기준**: "AI가 잘못된 방향으로 가면 되돌리기 비용이 큰가?" → 크다면 Plan & Build.
